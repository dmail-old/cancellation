{
  "version": 3,
  "sources": [
    "src/cancellation.js"
  ],
  "names": [
    "createCanceledError",
    "reason",
    "canceledError",
    "Error",
    "name",
    "toRejectedPromise",
    "Promise",
    "reject",
    "toPendingPromise",
    "pendingFlag",
    "cancellationTokenToPromise",
    "toRequestedPromise",
    "race",
    "resolve",
    "then",
    "value",
    "undefined",
    "createCancellationSource",
    "canceled",
    "callbacks",
    "requestedResolve",
    "cancelPromise",
    "requestedPromise",
    "cancel",
    "values",
    "reduce",
    "previous",
    "callback",
    "index",
    "register",
    "indexOf",
    "token",
    "cancellationTokenCompose",
    "tokens",
    "unregisters",
    "map",
    "forEach",
    "unregister",
    "createCancellationToken",
    "cancellationTokenWrapPromise",
    "cancellationToken",
    "promise"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import { arrayWithout } from \"./arrayHelper.js\"\n\n// https://github.com/tc39/proposal-cancellation/tree/master/stage0\nexport const createCanceledError = (reason) => {\n  const canceledError = new Error(`canceled because ${reason}`)\n  canceledError.name = \"CANCELED_ERROR\"\n  return canceledError\n}\n\nexport const toRejectedPromise = (reason) => Promise.reject(createCanceledError(reason))\n\n// It may lead to memory leak but it has to be tested\nexport const toPendingPromise = () => new Promise(() => {})\n\nconst pendingFlag = {}\nexport const cancellationTokenToPromise = ({ toRequestedPromise }) => {\n  return Promise.race([toRequestedPromise(), Promise.resolve(pendingFlag)]).then((value) => {\n    return value === pendingFlag ? undefined : toPendingPromise(value)\n  })\n}\n\nexport const createCancellationSource = () => {\n  let canceled = false\n  let callbacks = []\n  let requestedResolve\n  let cancelPromise\n  const requestedPromise = new Promise((resolve) => {\n    requestedResolve = resolve\n  })\n\n  const toRequestedPromise = () => requestedPromise\n\n  const cancel = (reason) => {\n    if (canceled) {\n      return cancelPromise\n    }\n    canceled = true\n    requestedResolve(reason)\n\n    const values = []\n    cancelPromise = callbacks\n      .reduce((previous, callback, index) => {\n        return previous.then(() => callback(reason)).then((value) => {\n          values[index] = value\n        })\n      }, Promise.resolve())\n      .then(() => values)\n    return cancelPromise\n  }\n\n  const register = (callback) => {\n    const index = callbacks.indexOf(callback)\n    if (index > -1) {\n      return () => {\n        callbacks = arrayWithout(callbacks, callback)\n      }\n    }\n    callbacks = [callback, ...callbacks]\n    return () => {\n      callbacks = arrayWithout(callbacks, callback)\n    }\n  }\n\n  return {\n    token: {\n      toRequestedPromise,\n      register,\n    },\n    cancel,\n  }\n}\n\nexport const cancellationTokenCompose = (...tokens) => {\n  const register = (callback) => {\n    const unregisters = tokens.map((token) => token.register(callback))\n    return () => unregisters.forEach((unregister) => unregister())\n  }\n\n  const toRequestedPromise = () => {\n    return Promise.race([tokens.map((token) => token.toRequestedPromise())])\n  }\n\n  return {\n    toRequestedPromise,\n    register,\n  }\n}\n\nexport const createCancellationToken = () => {\n  return {\n    toRequestedPromise: () => new Promise(() => {}),\n    register: () => () => {},\n  }\n}\n\nexport const cancellationTokenWrapPromise = (cancellationToken, promise) => {\n  return Promise.race([promise, cancellationToken.toRequestedPromise().then(toPendingPromise)])\n}\n\n// export const cancelllationTokenCanceled = {\n//   register: () => () => {},\n//   isRequested: () => true,\n//   toPromise: () => cancellationToPromise(),\n// }\n"
  ]
}